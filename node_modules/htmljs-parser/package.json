{
  "_args": [
    [
      {
        "raw": "htmljs-parser@^2.3.2",
        "scope": null,
        "escapedName": "htmljs-parser",
        "name": "htmljs-parser",
        "rawSpec": "^2.3.2",
        "spec": ">=2.3.2 <3.0.0",
        "type": "range"
      },
      "/Users/borislav/Development/Web/box/@Experimenting/marko/node_modules/marko"
    ]
  ],
  "_from": "htmljs-parser@>=2.3.2 <3.0.0",
  "_id": "htmljs-parser@2.3.2",
  "_inCache": true,
  "_location": "/htmljs-parser",
  "_nodeVersion": "7.8.0",
  "_npmOperationalInternal": {
    "host": "packages-18-east.internal.npmjs.com",
    "tmp": "tmp/htmljs-parser-2.3.2.tgz_1491260175750_0.7389763973187655"
  },
  "_npmUser": {
    "name": "pnidem",
    "email": "pnidem@gmail.com"
  },
  "_npmVersion": "4.2.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "htmljs-parser@^2.3.2",
    "scope": null,
    "escapedName": "htmljs-parser",
    "name": "htmljs-parser",
    "rawSpec": "^2.3.2",
    "spec": ">=2.3.2 <3.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/marko"
  ],
  "_resolved": "https://registry.npmjs.org/htmljs-parser/-/htmljs-parser-2.3.2.tgz",
  "_shasum": "1cc5bf9824a091c28820b33eaf78083a8eaa856c",
  "_shrinkwrap": null,
  "_spec": "htmljs-parser@^2.3.2",
  "_where": "/Users/borislav/Development/Web/box/@Experimenting/marko/node_modules/marko",
  "author": {
    "name": "Phillip Gates-Idem",
    "email": "phillip.idem@gmail.com"
  },
  "bugs": {
    "url": "https://github.com/philidem/htmljs-parser/issues"
  },
  "dependencies": {
    "char-props": "^0.1.5",
    "complain": "^1.0.0"
  },
  "description": "An HTML parser recognizes content and string placeholders and allows JavaScript expressions as attribute values",
  "devDependencies": {
    "chai": "^3.2.0",
    "colors": "^1.1.2",
    "jshint": "^2.8.0",
    "mocha": "^3.2.0"
  },
  "directories": {},
  "dist": {
    "shasum": "1cc5bf9824a091c28820b33eaf78083a8eaa856c",
    "tarball": "https://registry.npmjs.org/htmljs-parser/-/htmljs-parser-2.3.2.tgz"
  },
  "gitHead": "d671986de43b906dfbc916ebcf57d180d2e21120",
  "homepage": "https://github.com/philidem/htmljs-parser#readme",
  "keywords": [
    "HTML",
    "parser",
    "JavaScript",
    "expressions",
    "browser",
    "server",
    "nodejs",
    "template",
    "compiler"
  ],
  "license": "MIT",
  "main": "index.js",
  "maintainers": "Phillip Gates-Idem <phillip.idem@gmail.com>",
  "name": "htmljs-parser",
  "optionalDependencies": {},
  "publishConfig": {
    "registry": "https://registry.npmjs.org/"
  },
  "readme": "htmljs-parser\n=============\n\nHTML parsers written according to the HTML spec will interpret all\nattribute values as strings which makes it challenging to properly\ndescribe a value's type (boolean, string, number, array, etc.)\nor to provide a complex JavaScript expression as a value.\nThe ability to describe JavaScript expressions within attributes\nis important for HTML-based template compilers.\n\nFor example, consider a HTML-based template that wishes to\nsupport a custom tag named `<say-hello>` that supports an\nattribute named `message` that can be a string literal or a JavaScript expression.\n\n\nIdeally, the template compiler should be able to handle any of the following:\n\n```html\n<say-hello message=\"Hello world!\" />\n<say-hello message=(\"Hello \" + personName + \"!\") />\n<say-hello message=\"Hello ${personName}!\" />\n```\n\nThis parser extends the HTML grammar to add these important features:\n\n- JavaScript expressions as attribute values\n```html\n<say-hello message=(\"Hello \" + personName) count=2+2 large=true />\n```\n- Placeholders in the content of an element\n```html\n<div>\n    Hello ${personName}\n</div>\n```\n- Placeholders within attribute value strings\n```html\n<div data-message=\"Hello ${personName}!\">\n```\n- JavaScript flow-control statements within HTML elements\n```html\n<div for(a in b) />\n<div if(a === b) />\n```\n- JavaScript flow-control statements as elements\n```html\n<for (a in b)>\n<if (a in b)>\n```\n\n# Installation\n\n```bash\nnpm install htmljs-parser\n```\n\n# Usage\n\n```javascript\nvar parser = require('htmljs-parser').createParser({\n    onText: function(event) {\n        // Text within an HTML element\n        var value = event.value;\n    },\n\n    onPlaceholder: function(event) {\n        //  ${<value>]} // escape = true\n        // $!{<value>]} // escape = false\n        var value = event.value; // String\n        var escaped = event.escaped; // boolean\n        var withinBody = event.withinBody; // boolean\n        var withinAttribute = event.withinAttribute; // boolean\n        var withinString = event.withinString; // boolean\n        var withinOpenTag = event.withinOpenTag; // boolean\n        var pos = event.pos; // Integer\n    },\n\n    onCDATA: function(event) {\n        // <![CDATA[<value>]]>\n        var value = event.value; // String\n        var pos = event.pos; // Integer\n    },\n\n    onOpenTag: function(event) {\n        var tagName = event.tagName; // String\n        var attributes = event.attributes; // Array\n        var argument = event.argument; // Object\n        var pos = event.pos; // Integer\n    },\n\n    onCloseTag: function(event) {\n        // close tag\n        var tagName = event.tagName; // String\n        var pos = event.pos; // Integer\n    },\n\n    onDocumentType: function(event) {\n        // Document Type/DTD\n        // <!<value>>\n        // Example: <!DOCTYPE html>\n        var value = event.value; // String\n        var pos = event.pos; // Integer\n    },\n\n    onDeclaration: function(event) {\n        // Declaration\n        // <?<value>?>\n        // Example: <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        var value = event.value; // String\n        var pos = event.pos; // Integer\n    },\n\n    onComment: function(event) {\n        // Text within XML comment\n        var value = event.value; // String\n        var pos = event.pos; // Integer\n    },\n\n    onScriptlet: function(event) {\n        // Text within <% %>\n        var value = event.value; // String\n        var pos = event.pos; // Integer\n    },\n\n    onError: function(event) {\n        // Error\n        var message = event.message; // String\n        var code = event.code; // String\n        var pos = event.pos; // Integer\n    }\n});\n\nparser.parse(str);\n```\n\n## Content Parsing Modes\n\nThe parser, by default, will look for HTML tags within content. This behavior\nmight not be desirable for certain tags, so the parser allows the parsing mode\nto be changed (usually in response to an `onOpenTag` event).\n\nThere are three content parsing modes:\n\n- **HTML Content (DEFAULT):**\n    The parser will look for any HTML tag and content placeholders while in\n    this mode and parse opening and closing tags accordingly.\n\n- **Parsed Text Content**: The parser will look for the closing tag that matches\n    the current open tag as well as content placeholders but all other content\n    will be interpreted as text.\n\n- **Static Text Content**: The parser will look for the closing tag that matches\n    the current open tag but all other content will be interpreted as raw text.\n\n```javascript\nvar htmljs = require('htmljs-parser');\nvar parser = htmljs.createParser({\n    onOpenTag: function(event) {\n        // open tag\n        switch(event.tagName) {\n            case 'textarea':\n                //fall through\n            case 'script':\n                //fall through\n            case 'style':\n                // parse the content within these tags but only\n                // look for placeholders and the closing tag.\n                parser.enterParsedTextContentState();\n                break;\n            case 'dummy'\n                // treat content within <dummy>...</dummy> as raw\n                // text and ignore other tags and placeholders\n                parser.enterStaticTextContentState();\n                break;\n            default:\n                // The parser will switch to HTML content parsing mode\n                // if the parsing mode is not explicitly changed by\n                // \"onOpenTag\" function.\n        }\n    }\n});\n\nparser.parse(str);\n```\n\n## Parsing Events\n\nThe `htmljs-parser` is an event-based parser which means that it will emit\nevents as it is parsing the document. Events are emitted via calls\nto `on<eventname>` function which are supplied as properties in the options\nvia call to `require('htmljs-parser').createParser(options)`.\n\n### onOpenTag\n\nThe `onOpenTag` function will be called each time an opening tag is\nencountered.\n\n**EXAMPLE: Simple tag**\n\nINPUT:\n\n```html\n<div>\n```\n\nOUTPUT EVENT:\n\n```javascript\n{\n    type: 'openTag',\n    tagName: 'div',\n    attributes: []\n}\n```\n\n**EXAMPLE: Tag with literal attribute values**\n\nINPUT:\n\n```html\n<div class=\"demo\" disabled=false data-number=123>\n```\n\nOUTPUT EVENT:\n\n```javascript\n{\n    type: 'openTag',\n    tagName: 'div',\n    attributes: [\n        {\n            name: 'class',\n            value: '\"demo\"',\n            literalValue: 'demo'\n        },\n        {\n            name: 'disabled',\n            value: 'false',\n            literalValue: false\n        },\n        {\n            name: 'data-number',\n            value: '123',\n            literalValue: 123\n        }\n    ]\n}\n```\n\n**EXAMPLE: Tag with expression attribute**\n\nINPUT:\n\n```html\n<say-something message=(\"Hello \"+data.name)/>\n```\n\nOUTPUT EVENT:\n\n```javascript\n{\n    type: 'openTag',\n    tagName: 'div',\n    attributes: [\n        {\n            name: 'message',\n            value: '\"Hello \"+data.name'\n        }\n    ]\n}\n```\n\n**EXAMPLE: Tag with an argument**\n\nINPUT:\n\n```html\n<for(var i = 0; i < 10; i++)>\n```\n\nOUTPUT EVENT:\n\n```javascript\n{\n    type: 'openTag',\n    tagName: 'for',\n    argument: {\n        value: 'var i = 0; i < 10; i++',\n        pos: ... // Integer\n    },\n    attributes: []\n}\n```\n\n**EXAMPLE: Attribute with an argument**\n\nINPUT:\n\n```html\n<div if(x > y)>\n```\n\nOUTPUT EVENT:\n\n```javascript\n{\n    type: 'openTag',\n    tagName: 'div',\n    attributes: [\n        {\n            name: 'if',\n            argument: {\n                value: 'x > y',\n                pos: ... // Integer\n            }\n        }\n    ]\n}\n```\n\n### onCloseTag\n\nThe `onCloseTag` function will be called each time a closing tag is\nencountered.\n\n**EXAMPLE: Simple close tag**\n\nINPUT:\n\n```html\n</div>\n```\n\nOUTPUT EVENT:\n\n```javascript\n{\n    type: 'closeTag',\n    tagName: 'div'\n}\n```\n\n### onText\n\nThe `onText` function will be called each time within an element\nwhen textual data is encountered.\n\n**NOTE:** Text within `<![CDATA[` `]]>` will be emitted via call\nto `onCDATA`.\n\n**EXAMPLE**\n\nIn the following example code, the `TEXT` sequences will be emitted as\ntext events.\n\nINPUT:\n\n```html\nSimple text\n```\n\nOUTPUT EVENT:\n\n```javascript\n{\n    type: 'text',\n    value: 'Simple text'\n}\n```\n\n### onCDATA\n\nThe `onCDATA` function will be called when text within `<![CDATA[` `]]>`\nis encountered.\n\n**EXAMPLE:**\n\nINPUT:\n\n```html\n<![CDATA[This is text]]>\n```\n\nOUTPUT EVENT:\n\n```javascript\n{\n    type: 'cdata',\n    value: 'This is text'\n}\n```\n\n### onPlaceholder\n\nThe `onPlaceholder` function will be called each time a placeholder\nis encountered.\n\nIf the placeholder starts with the `$!{` sequence then `event.escape`\nwill be `false`.\n\nIf the placeholder starts with the `${` sequence then `event.escape` will be\n`true`.\n\nText within `<![CDATA[` `]]>` and `<!--` `-->` will not be parsed so you\ncannot use placeholders for these blocks of code.\n\n**EXAMPLE:**\n\nINPUT:\n\n```html\n${\"This is an escaped placeholder\"}\n$!{\"This is a non-escaped placeholder\"}\n```\n\nOUTPUT EVENTS\n\n```html\n${name}\n```\n\n```javascript\n{\n    type: 'placeholder',\n    value: 'name',\n    escape: true\n}\n```\n\n--------\n\n```html\n$!{name}\n```\n\n```javascript\n{\n    type: 'placeholder',\n    value: 'name',\n    escape: true\n}\n```\n\n**NOTE:**\nThe `escape` flag is merely informational. The application code is responsible\nfor interpreting this flag to properly escape the expression.\n\nHere's an example of modifying the expression based on the `event.escape` flag:\n\n```javascript\nonPlaceholder: function(event) {\n    if (event.escape) {\n        event.value = 'escapeXml(' + event.value + ')';\n    }\n}\n```\n\n### onDocumentType\n\nThe `onDocumentType` function will be called when the document type declaration\nis encountered _anywhere_ in the content.\n\n**EXAMPLE:**\n\nINPUT:\n\n```html\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0//EN\">\n```\n\nOUTPUT EVENT:\n\n```javascript\n{\n    type: 'documentType',\n    value: 'DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0//EN\"'\n}\n```\n\n### onDeclaration\n\nThe `onDeclaration` function will be called when an XML declaration\nis encountered _anywhere_ in the content.\n\n**EXAMPLE:**\n\nINPUT:\n\n```html\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n```\n\nOUTPUT EVENT:\n\n```javascript\n{\n    type: 'declaration',\n    value: 'xml version=\"1.0\" encoding=\"UTF-8\"'\n}\n```\n\n### onComment\n\nThe `onComment` function will be called when text within `<!--` `-->`\nis encountered.\n\n**EXAMPLE:**\n\nINPUT:\n\n```html\n<!--This is a comment-->\n```\n\nOUTPUT EVENT:\n\n```javascript\n{\n    type: 'comment',\n    value: 'This is a comment'\n}\n```\n\n### onScriptlet\n\nThe `onScriptlet` function will be called when text within `<%` `%>`\nis encountered.\n\n**EXAMPLE:**\n\nINPUT:\n\n```html\n<% console.log(\"Hello World!\"); %>\n```\n\nOUTPUT EVENT:\n\n```javascript\n{\n    type: 'scriptlet',\n    value: ' console.log(\"Hello World!\"); '\n}\n```\n\n### onError\n\nThe `onError` function will be called when malformed content is detected.\nThe most common cause for an error is due to reaching the end of the\ninput while still parsing an open tag, close tag, XML comment, CDATA section,\nDTD, XML declaration, or placeholder.\n\nPossible error codes:\n\n- `MISSING_END_TAG`\n- `MISSING_END_DELIMITER`\n- `MALFORMED_OPEN_TAG`\n- `MALFORMED_CLOSE_TAG`\n- `MALFORMED_CDATA`\n- `MALFORMED_PLACEHOLDER`\n- `MALFORMED_DOCUMENT_TYPE`\n- `MALFORMED_DECLARATION`\n- `MALFORMED_COMMENT`\n- `EXTRA_CLOSING_TAG`\n- `MISMATCHED_CLOSING_TAG`\n- ...\n\n**EXAMPLE:**\n\nINPUT:\n\n```html\n<a href=\"\n```\n\nOUTPUT EVENT:\n\n```javascript\n{\n    type: 'error',\n    code: 'MALFORMED_OPEN_TAG',\n    message: 'EOF reached while parsing open tag.',\n    pos: 0,\n    endPos: 9\n}\n```\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/philidem/htmljs-parser.git"
  },
  "scripts": {
    "jshint": "jshint *.js",
    "mocha": "mocha --ui bdd --reporter spec ./test",
    "test": "npm run mocha && npm run jshint"
  },
  "version": "2.3.2"
}
